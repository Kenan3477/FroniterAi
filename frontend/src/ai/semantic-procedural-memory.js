// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
// Performance optimized by Autonomous Evolution System
/**
 * Semantic Memory - Knowledge and facts storage
 * Stores factual information, concepts, and relationships
 */

class SemanticMemory {
    constructor() {
        this.knowledgeGraph = new KnowledgeGraph();
        this.conceptNetwork = new ConceptNetwork();
        this.factDatabase = new FactDatabase();
        this.domainKnowledge = new DomainKnowledge();
        
        this.initializeBaseKnowledge();
//         console.log('🧠 Semantic Memory Initialized');
    }

    initializeBaseKnowledge() {
        // Initialize with fundamental concepts and relationships
        this.loadBusinessKnowledge();
        this.loadTechnicalKnowledge();
        this.loadGeneralKnowledge();
    }

    addKnowledge(concept, facts, relationships = []) {
        this.knowledgeGraph.addNode(concept, facts);
        this.conceptNetwork.addConcept(concept, facts);
        
        relationships.forEach(rel => {
            this.knowledgeGraph.addEdge(concept, rel.target, rel.type, rel.strength);
            this.conceptNetwork.addRelation(concept, rel.target, rel.type);
        });

        facts.forEach(fact => {
            this.factDatabase.addFact(fact, concept);
        });
    }

    queryKnowledge(query, context = {}) {
        const conceptMatches = this.conceptNetwork.findRelatedConcepts(query);
        const factMatches = this.factDatabase.searchFacts(query);
        const graphPaths = this.knowledgeGraph.findPaths(query, context);
        
        return {
            concepts: conceptMatches,
            facts: factMatches,
            relationships: graphPaths,
            confidence: this.calculateConfidence(conceptMatches, factMatches, graphPaths)
        };
    }

    loadBusinessKnowledge() {
        // Revenue concepts
        this.addKnowledge('revenue', [
            'Revenue is the total income generated by a business',
            'Revenue growth indicates business expansion',
            'Revenue can be recurring or one-time',
            'Revenue recognition follows accounting standards'
        ], [
            { target: 'profit', type: 'contributes_to', strength: 0.9 },
            { target: 'sales', type: 'derived_from', strength: 0.8 },
            { target: 'business_growth', type: 'indicates', strength: 0.7 }
        ]);

        // Customer concepts
        this.addKnowledge('customer_retention', [
            'Customer retention measures loyalty over time',
            'Higher retention reduces acquisition costs',
            'Retention rates above 90% are excellent for most industries',
            'Retention impacts lifetime value calculations'
        ], [
            { target: 'customer_satisfaction', type: 'correlates_with', strength: 0.8 },
            { target: 'revenue', type: 'affects', strength: 0.7 },
            { target: 'business_sustainability', type: 'indicates', strength: 0.9 }
        ]);

        // Analytics concepts
        this.addKnowledge('business_analytics', [
            'Analytics transforms data into actionable insights',
            'KPIs measure business performance',
            'Predictive analytics forecasts future trends',
            'Real-time analytics enables quick decisions'
        ], [
            { target: 'data', type: 'processes', strength: 0.9 },
            { target: 'decision_making', type: 'supports', strength: 0.8 },
            { target: 'business_intelligence', type: 'part_of', strength: 0.9 }
        ]);
    }

    loadTechnicalKnowledge() {
        // Website analysis
        this.addKnowledge('seo', [
            'SEO optimizes websites for search engines',
            'Good SEO improves organic traffic',
            'Technical SEO includes site speed and structure',
            'Content SEO focuses on relevant keywords'
        ], [
            { target: 'website_traffic', type: 'increases', strength: 0.8 },
            { target: 'search_rankings', type: 'improves', strength: 0.9 },
            { target: 'content_quality', type: 'requires', strength: 0.7 }
        ]);

        // Technology concepts
        this.addKnowledge('artificial_intelligence', [
            'AI enables machines to simulate human intelligence',
            'Machine learning is a subset of AI',
            'AI can process natural language',
            'AI improves through training and experience'
        ], [
            { target: 'machine_learning', type: 'includes', strength: 0.9 },
            { target: 'automation', type: 'enables', strength: 0.8 },
            { target: 'decision_support', type: 'provides', strength: 0.7 }
        ]);
    }

    loadGeneralKnowledge() {
        // Communication concepts
        this.addKnowledge('conversation', [
            'Conversations involve exchange of information',
            'Good conversations maintain context',
            'Active listening improves conversation quality',
            'Conversations can have multiple topics'
        ], [
            { target: 'communication', type: 'form_of', strength: 0.9 },
            { target: 'understanding', type: 'builds', strength: 0.8 },
            { target: 'relationship', type: 'strengthens', strength: 0.7 }
        ]);
    }

    calculateConfidence(conceptMatches, factMatches, graphPaths) {
        const conceptScore = Math.min(conceptMatches.length * 0.2, 1.0);
        const factScore = Math.min(factMatches.length * 0.15, 1.0);
        const pathScore = Math.min(graphPaths.length * 0.1, 0.5);
        
        return Math.min(conceptScore + factScore + pathScore, 1.0);
    }
}

/**
 * Procedural Memory - How to perform tasks
 * Stores procedures, workflows, and task execution knowledge
 */
class ProceduralMemory {
    constructor() {
        this.procedures = new Map();
        this.workflows = new Map();
        this.taskTemplates = new Map();
        this.executionPatterns = new Map();
        
        this.initializeBaseProcedures();
//         console.log('🔧 Procedural Memory Initialized');
    }

    initializeBaseProcedures() {
        this.loadAnalysisProcedures();
        this.loadConversationProcedures();
        this.loadProblemSolvingProcedures();
    }

    addProcedure(name, procedure) {
        this.procedures.set(name, {
            ...procedure,
            created: Date.now(),
            usage_count: 0,
            success_rate: 1.0
        });
    }

    getProcedure(taskType, context = {}) {
        const candidates = Array.from(this.procedures.entries())
            .filter(([name, proc]) => this.matchesProcedure(proc, taskType, context))
            .sort((a, b) => this.scoreProcedure(b[1], context) - this.scoreProcedure(a[1], context));
        
        if (candidates.length > 0) {
            const [name, procedure] = candidates[0];
            this.procedures.get(name).usage_count++;
            return procedure;
        }
        
        return this.generateAdHocProcedure(taskType, context);
    }

    loadAnalysisProcedures() {
        this.addProcedure('website_analysis', {
            type: 'analysis',
            description: 'Analyze website URLs for business intelligence',
            steps: [
                {
                    action: 'extract_url',
                    description: 'Extract and validate URL from input',
                    requirements: ['valid_url'],
                    outputs: ['clean_url', 'domain']
                },
                {
                    action: 'analyze_structure',
                    description: 'Analyze URL structure and domain',
                    requirements: ['clean_url'],
                    outputs: ['business_type', 'industry_hints']
                },
                {
                    action: 'infer_business_context',
                    description: 'Infer business type and industry',
                    requirements: ['business_type', 'industry_hints'],
                    outputs: ['industry', 'business_category']
                },
                {
                    action: 'generate_insights',
                    description: 'Generate actionable insights',
                    requirements: ['industry', 'business_category'],
                    outputs: ['insights', 'recommendations']
                },
                {
                    action: 'explain_reasoning',
                    description: 'Provide reasoning for conclusions',
                    requirements: ['insights'],
                    outputs: ['reasoning', 'confidence_level']
                }
            ],
            triggers: ['url_detected', 'analysis_request'],
            context_requirements: [],
            success_indicators: ['insights_generated', 'reasoning_provided']
        });

        this.addProcedure('business_metrics_analysis', {
            type: 'analysis',
            description: 'Analyze business performance metrics',
            steps: [
                {
                    action: 'identify_metrics',
                    description: 'Identify relevant business metrics',
                    requirements: ['business_context'],
                    outputs: ['metric_list', 'metric_categories']
                },
                {
                    action: 'calculate_performance',
                    description: 'Calculate performance indicators',
                    requirements: ['metric_list', 'historical_data'],
                    outputs: ['current_performance', 'trend_analysis']
                },
                {
                    action: 'benchmark_comparison',
                    description: 'Compare against industry benchmarks',
                    requirements: ['current_performance', 'industry_data'],
                    outputs: ['benchmark_results', 'performance_gaps']
                },
                {
                    action: 'generate_recommendations',
                    description: 'Create actionable recommendations',
                    requirements: ['benchmark_results', 'performance_gaps'],
                    outputs: ['recommendations', 'priority_actions']
                }
            ],
            triggers: ['metrics_request', 'performance_inquiry'],
            context_requirements: ['business_setup'],
            success_indicators: ['recommendations_provided', 'benchmarks_compared']
        });
    }

    loadConversationProcedures() {
        this.addProcedure('topic_transition', {
            type: 'conversation',
            description: 'Smoothly transition between conversation topics',
            steps: [
                {
                    action: 'acknowledge_current_topic',
                    description: 'Acknowledge the current discussion',
                    requirements: ['current_topic'],
                    outputs: ['acknowledgment']
                },
                {
                    action: 'find_connection',
                    description: 'Find logical connection to new topic',
                    requirements: ['current_topic', 'new_topic'],
                    outputs: ['connection_point', 'transition_phrase']
                },
                {
                    action: 'bridge_topics',
                    description: 'Create smooth transition',
                    requirements: ['connection_point', 'transition_phrase'],
                    outputs: ['transition_statement']
                },
                {
                    action: 'introduce_new_topic',
                    description: 'Introduce the new topic naturally',
                    requirements: ['transition_statement', 'new_topic'],
                    outputs: ['topic_introduction']
                }
            ],
            triggers: ['topic_shift_detected', 'new_topic_introduced'],
            context_requirements: ['conversation_history'],
            success_indicators: ['smooth_transition', 'context_maintained']
        });

        this.addProcedure('clarification_request', {
            type: 'conversation',
            description: 'Request clarification when needed',
            steps: [
                {
                    action: 'identify_ambiguity',
                    description: 'Identify unclear or ambiguous elements',
                    requirements: ['user_input'],
                    outputs: ['ambiguous_elements', 'clarity_needs']
                },
                {
                    action: 'formulate_questions',
                    description: 'Create specific clarifying questions',
                    requirements: ['ambiguous_elements'],
                    outputs: ['clarifying_questions']
                },
                {
                    action: 'prioritize_questions',
                    description: 'Order questions by importance',
                    requirements: ['clarifying_questions', 'conversation_context'],
                    outputs: ['priority_questions']
                },
                {
                    action: 'present_clarification',
                    description: 'Present questions in conversational manner',
                    requirements: ['priority_questions'],
                    outputs: ['clarification_response']
                }
            ],
            triggers: ['ambiguous_input', 'insufficient_context'],
            context_requirements: [],
            success_indicators: ['clarity_achieved', 'user_understanding']
        });
    }

    loadProblemSolvingProcedures() {
        this.addProcedure('diagnostic_analysis', {
            type: 'problem_solving',
            description: 'Diagnose and analyze problems systematically',
            steps: [
                {
                    action: 'problem_definition',
                    description: 'Clearly define the problem',
                    requirements: ['problem_description'],
                    outputs: ['problem_statement', 'problem_scope']
                },
                {
                    action: 'gather_information',
                    description: 'Collect relevant information',
                    requirements: ['problem_statement'],
                    outputs: ['relevant_data', 'context_information']
                },
                {
                    action: 'identify_causes',
                    description: 'Identify potential root causes',
                    requirements: ['relevant_data', 'context_information'],
                    outputs: ['potential_causes', 'cause_likelihood']
                },
                {
                    action: 'evaluate_solutions',
                    description: 'Evaluate possible solutions',
                    requirements: ['potential_causes'],
                    outputs: ['solution_options', 'solution_feasibility']
                },
                {
                    action: 'recommend_action',
                    description: 'Recommend best course of action',
                    requirements: ['solution_options', 'solution_feasibility'],
                    outputs: ['recommended_solution', 'implementation_plan']
                }
            ],
            triggers: ['problem_reported', 'troubleshooting_request'],
            context_requirements: [],
            success_indicators: ['solution_identified', 'action_plan_provided']
        });
    }

    matchesProcedure(procedure, taskType, context) {
        // Check if procedure type matches
        if (procedure.type !== taskType && !procedure.triggers.includes(taskType)) {
            return false;
        }

        // Check context requirements
        for (const requirement of procedure.context_requirements) {
            if (!context[requirement]) {
                return false;
            }
        }

        return true;
    }

    scoreProcedure(procedure, context) {
        let score = procedure.success_rate || 1.0;
        
        // Boost frequently used procedures
        score += Math.log(procedure.usage_count + 1) * 0.1;
        
        // Boost recently created procedures (learning)
        const age = Date.now() - procedure.created;
        const recencyBoost = Math.exp(-age / (1000 * 60 * 60 * 24 * 7)) * 0.2; // Week decay
        score += recencyBoost;
        
        return score;
    }

    generateAdHocProcedure(taskType, context) {
        // Generate a basic procedure for unknown task types
        return {
            type: taskType,
            description: `Ad-hoc procedure for ${taskType}`,
            steps: [
                {
                    action: 'analyze_request',
                    description: 'Analyze the user request',
                    requirements: ['user_input'],
                    outputs: ['request_analysis']
                },
                {
                    action: 'apply_knowledge',
                    description: 'Apply relevant knowledge',
                    requirements: ['request_analysis'],
                    outputs: ['knowledge_application']
                },
                {
                    action: 'generate_response',
                    description: 'Generate appropriate response',
                    requirements: ['knowledge_application'],
                    outputs: ['response']
                }
            ],
            triggers: [taskType],
            context_requirements: [],
            success_indicators: ['response_generated'],
            created: Date.now(),
            usage_count: 0,
            success_rate: 0.7 // Lower initial success rate for ad-hoc procedures
        };
    }

    executeProcedure(procedure, inputs, context) {
        const execution = {
            procedure: procedure.description,
            steps: [],
            outputs: {},
            success: false,
            startTime: Date.now()
        };

        try {
            for (const step of procedure.steps) {
                const stepResult = this.executeStep(step, execution.outputs, context);
                execution.steps.push({
                    step: step.action,
                    description: step.description,
                    success: stepResult.success,
                    outputs: stepResult.outputs
                });

                if (stepResult.success) {
                    Object.assign(execution.outputs, stepResult.outputs);
                } else {
                    execution.failure_step = step.action;
                    break;
                }
            }

            execution.success = this.checkSuccessIndicators(procedure.success_indicators, execution.outputs);
            execution.endTime = Date.now();
            execution.duration = execution.endTime - execution.startTime;

            // Update success rate
            this.updateSuccessRate(procedure, execution.success);

            return execution;
        } catch (error) {
            execution.error = error.message;
            execution.success = false;
            return execution;
        }
    }

    executeStep(step, availableData, context) {
        // Check requirements
        for (const requirement of step.requirements) {
            if (!availableData[requirement] && !context[requirement]) {
                return { success: false, error: `Missing requirement: ${requirement}` };
            }
        }

        // Simulate step execution (in real implementation, this would call actual functions)
        const outputs = {};
        step.outputs.forEach(output => {
            outputs[output] = this.generateMockOutput(output, availableData, context);
        });

        return { success: true, outputs };
    }

    generateMockOutput(outputType, availableData, context) {
        // Generate mock outputs for demonstration
        const mockOutputs = {
            'clean_url': availableData.url || context.url || 'https://example.com',
            'domain': 'example.com',
            'business_type': 'Technology Company',
            'industry': 'Software',
            'insights': 'Strong digital presence with focus on user experience',
            'recommendations': ['Optimize mobile experience', 'Improve load times'],
            'reasoning': 'Based on URL structure and domain analysis'
        };

        return mockOutputs[outputType] || `Generated ${outputType}`;
    }

    checkSuccessIndicators(indicators, outputs) {
        return indicators.every(indicator => 
            outputs[indicator] || outputs[indicator.replace('_', '')] 
        );
    }

    updateSuccessRate(procedure, success) {
        const current = procedure.success_rate || 1.0;
        const alpha = 0.1; // Learning rate
        procedure.success_rate = current * (1 - alpha) + (success ? 1.0 : 0.0) * alpha;
    }
}

/**
 * Knowledge Graph for semantic relationships
 */
class KnowledgeGraph {
    constructor() {
        this.nodes = new Map();
        this.edges = new Map();
    }

    addNode(concept, attributes = {}) {
        this.nodes.set(concept, {
            id: concept,
            attributes,
            created: Date.now()
        });
    }

    addEdge(from, to, relationship, strength = 1.0) {
        const edgeId = `${from}->${to}`;
        this.edges.set(edgeId, {
            from,
            to,
            relationship,
            strength,
            created: Date.now()
        });
    }

    findPaths(query, context, maxDepth = 3) {
        const startNodes = this.findRelevantNodes(query);
        const paths = [];

        startNodes.forEach(startNode => {
            const found = this.breadthFirstSearch(startNode, maxDepth);
            paths.push(...found);
        });

        return paths.sort((a, b) => b.relevance - a.relevance).slice(0, 10);
    }

    findRelevantNodes(query) {
        const queryWords = query.toLowerCase().split(' ');
        const relevant = [];

        this.nodes.forEach((node, concept) => {
            const conceptWords = concept.toLowerCase().split('_');
            const overlap = queryWords.filter(word => conceptWords.includes(word)).length;
            
            if (overlap > 0) {
                relevant.push({
                    concept,
                    relevance: overlap / queryWords.length
                });
            }
        });

        return relevant.sort((a, b) => b.relevance - a.relevance).slice(0, 5);
    }

    breadthFirstSearch(startNode, maxDepth) {
        const queue = [{ node: startNode.concept, path: [startNode.concept], depth: 0 }];
        const visited = new Set();
        const paths = [];

        while (queue.length > 0) {
            const current = queue.shift();
            
            if (visited.has(current.node) || current.depth >= maxDepth) {
                continue;
            }

            visited.add(current.node);
            
            // Find connected nodes
            this.edges.forEach(edge => {
                if (edge.from === current.node && !visited.has(edge.to)) {
                    const newPath = [...current.path, edge.to];
                    queue.push({
                        node: edge.to,
                        path: newPath,
                        depth: current.depth + 1
                    });
                    
                    paths.push({
                        path: newPath,
                        relationships: this.getPathRelationships(newPath),
                        relevance: this.calculatePathRelevance(newPath)
                    });
                }
            });
        }

        return paths;
    }

    getPathRelationships(path) {
        const relationships = [];
        for (let i = 0; i < path.length - 1; i++) {
            const edgeId = `${path[i]}->${path[i + 1]}`;
            const edge = this.edges.get(edgeId);
            if (edge) {
                relationships.push(edge.relationship);
            }
        }
        return relationships;
    }

    calculatePathRelevance(path) {
        let relevance = 1.0;
        
        // Shorter paths are more relevant
        relevance *= Math.exp(-path.length * 0.2);
        
        // Calculate based on edge strengths
        for (let i = 0; i < path.length - 1; i++) {
            const edgeId = `${path[i]}->${path[i + 1]}`;
            const edge = this.edges.get(edgeId);
            if (edge) {
                relevance *= edge.strength;
            }
        }
        
        return relevance;
    }
}

/**
 * Concept Network for semantic relationships
 */
class ConceptNetwork {
    constructor() {
        this.concepts = new Map();
        this.relations = new Map();
    }

    addConcept(name, attributes) {
        this.concepts.set(name, {
            name,
            attributes,
            related: new Set(),
            strength: 1.0
        });
    }

    addRelation(concept1, concept2, relationType) {
        const relationId = `${concept1}:${concept2}`;
        this.relations.set(relationId, {
            type: relationType,
            strength: 1.0,
            created: Date.now()
        });

        if (this.concepts.has(concept1)) {
            this.concepts.get(concept1).related.add(concept2);
        }
        if (this.concepts.has(concept2)) {
            this.concepts.get(concept2).related.add(concept1);
        }
    }

    findRelatedConcepts(query, maxResults = 10) {
        const queryWords = query.toLowerCase().split(' ');
        const matches = [];

        this.concepts.forEach((concept, name) => {
            const nameWords = name.toLowerCase().split('_');
            const attributeText = Array.isArray(concept.attributes) ? 
                concept.attributes.join(' ').toLowerCase() : 
                String(concept.attributes).toLowerCase();
            
            let score = 0;
            queryWords.forEach(word => {
                if (nameWords.includes(word)) score += 2;
                if (attributeText.includes(word)) score += 1;
            });

            if (score > 0) {
                matches.push({
                    concept: name,
                    attributes: concept.attributes,
                    score,
                    related: Array.from(concept.related)
                });
            }
        });

        return matches
            .sort((a, b) => b.score - a.score)
            .slice(0, maxResults);
    }
}

/**
 * Fact Database for storing factual information
 */
class FactDatabase {
    constructor() {
        this.facts = [];
        this.factIndex = new Map();
    }

    addFact(fact, source = 'unknown') {
        const factEntry = {
            id: this.generateFactId(),
            content: fact,
            source,
            created: Date.now(),
            confidence: 1.0,
            keywords: this.extractKeywords(fact)
        };

        this.facts.push(factEntry);
        
        // Index by keywords
        factEntry.keywords.forEach(keyword => {
            if (!this.factIndex.has(keyword)) {
                this.factIndex.set(keyword, []);
            }
            this.factIndex.get(keyword).push(factEntry.id);
        });
    }

    generateFactId() {
        return `fact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    extractKeywords(fact) {
        return fact.toLowerCase()
            .split(/\s+/)
            .filter(word => word.length > 3)
            .filter(word => !['this', 'that', 'with', 'from', 'they', 'have', 'been'].includes(word));
    }

    searchFacts(query, maxResults = 10) {
        const queryWords = this.extractKeywords(query);
        const factScores = new Map();

        queryWords.forEach(word => {
            const factIds = this.factIndex.get(word) || [];
            factIds.forEach(factId => {
                factScores.set(factId, (factScores.get(factId) || 0) + 1);
            });
        });

        const results = Array.from(factScores.entries())
            .map(([factId, score]) => {
                const fact = this.facts.find(f => f.id === factId);
                return { fact, score };
            })
            .sort((a, b) => b.score - a.score)
            .slice(0, maxResults);

        return results.map(r => r.fact);
    }
}

/**
 * Domain Knowledge for specialized knowledge areas
 */
class DomainKnowledge {
    constructor() {
        this.domains = new Map();
        this.initializeDomains();
    }

    initializeDomains() {
        this.addDomain('business', {
            metrics: ['revenue', 'profit', 'growth', 'retention', 'satisfaction'],
            processes: ['sales', 'marketing', 'operations', 'finance'],
            strategies: ['growth', 'efficiency', 'innovation', 'competitive']
        });

        this.addDomain('technology', {
            categories: ['software', 'hardware', 'ai', 'web', 'mobile'],
            concepts: ['scalability', 'security', 'performance', 'usability'],
            methodologies: ['agile', 'devops', 'testing', 'deployment']
        });

        this.addDomain('analytics', {
            types: ['descriptive', 'predictive', 'prescriptive'],
            metrics: ['kpi', 'roi', 'conversion', 'engagement'],
            tools: ['dashboards', 'reports', 'visualization', 'modeling']
        });
    }

    addDomain(name, knowledge) {
        this.domains.set(name, {
            name,
            knowledge,
            created: Date.now()
        });
    }

    getDomainKnowledge(domain) {
        return this.domains.get(domain);
    }

    findRelevantDomains(query) {
        const queryWords = query.toLowerCase().split(' ');
        const relevantDomains = [];

        this.domains.forEach((domain, name) => {
            let relevance = 0;
            Object.values(domain.knowledge).forEach(items => {
                if (Array.isArray(items)) {
                    items.forEach(item => {
                        if (queryWords.some(word => item.includes(word))) {
                            relevance += 1;
                        }
                    });
                }
            });

            if (relevance > 0) {
                relevantDomains.push({ domain: name, relevance });
            }
        });

        return relevantDomains.sort((a, b) => b.relevance - a.relevance);
    }
}

/**
 * Memory Coordinator - Orchestrates all memory systems
 */
class MemoryCoordinator {
    constructor() {
        this.consolidationThreshold = 100; // Consolidate after 100 operations
        this.operationCount = 0;
    }

    processMemories(input, context, memories) {
        this.operationCount++;

        // Query all memory systems
        const workingContext = memories.working.getCurrentContext();
        const episodicRecall = memories.episodic.retrieveRelevantEpisodes(input);
        const semanticKnowledge = memories.semantic.queryKnowledge(input, context);
        const proceduralMatch = memories.procedural.getProcedure('analysis', context);

        // Integrate memories
        const integratedMemory = this.integrateMemories({
            working: workingContext,
            episodic: episodicRecall,
            semantic: semanticKnowledge,
            procedural: proceduralMatch
        });

        // Trigger consolidation if needed
        if (this.operationCount >= this.consolidationThreshold) {
            this.consolidate(memories);
            this.operationCount = 0;
        }

        return integratedMemory;
    }

    integrateMemories(memoryResults) {
        return {
            currentContext: memoryResults.working,
            relevantExperiences: memoryResults.episodic,
            applicableKnowledge: memoryResults.semantic,
            suggestedProcedure: memoryResults.procedural,
            confidence: this.calculateIntegratedConfidence(memoryResults),
            recommendations: this.generateRecommendations(memoryResults)
        };
    }

    calculateIntegratedConfidence(memoryResults) {
        const weights = {
            working: 0.3,
            episodic: 0.2,
            semantic: 0.3,
            procedural: 0.2
        };

        let confidence = 0;
        
        // Working memory confidence (based on context quality)
        confidence += weights.working * Math.min(memoryResults.working.activeTopics.length * 0.2, 1.0);
        
        // Episodic memory confidence (based on relevant episodes)
        confidence += weights.episodic * Math.min(memoryResults.episodic.length * 0.1, 1.0);
        
        // Semantic memory confidence
        confidence += weights.semantic * (memoryResults.semantic.confidence || 0);
        
        // Procedural memory confidence
        confidence += weights.procedural * (memoryResults.procedural.success_rate || 0);

        return Math.min(confidence, 1.0);
    }

    generateRecommendations(memoryResults) {
        const recommendations = [];

        // Based on working memory
        if (memoryResults.working.activeTopics.length > 5) {
            recommendations.push('Consider focusing on fewer topics for clearer conversation');
        }

        // Based on episodic memory
        if (memoryResults.episodic.length > 0) {
            recommendations.push('Reference previous conversations to build continuity');
        }

        // Based on semantic knowledge
        if (memoryResults.semantic.confidence > 0.8) {
            recommendations.push('Leverage high-confidence knowledge for detailed explanations');
        }

        // Based on procedural memory
        if (memoryResults.procedural.success_rate > 0.9) {
            recommendations.push('Follow established procedure for optimal results');
        }

        return recommendations;
    }

    consolidate(memories) {
//         console.log('🔄 Starting memory consolidation...');
        
        // Consolidate working memory to episodic
        this.consolidateWorkingToEpisodic(memories.working, memories.episodic);
        
        // Extract semantic knowledge from episodes
        this.extractSemanticFromEpisodic(memories.episodic, memories.semantic);
        
        // Optimize procedural memory
        this.optimizeProceduralMemory(memories.procedural);
        
//         console.log('✅ Memory consolidation complete');
    }

    consolidateWorkingToEpisodic(working, episodic) {
        const context = working.getCurrentContext();
        if (context.conversationThread.length > 10) {
            const conversation = context.conversationThread.splice(0, -5); // Keep last 5
            episodic.addEpisode(conversation, {
                topics: context.activeTopics,
                emotionalState: context.emotionalState
            });
        }
    }

    extractSemanticFromEpisodic(episodic, semantic) {
        // Extract patterns and facts from recent episodes
        const recentEpisodes = episodic.episodes.slice(-10);
        recentEpisodes.forEach(episode => {
            episode.conversation.mainTopics.forEach(topic => {
                if (episode.metadata.taskOutcomes.some(t => t.outcome === 'completed')) {
                    semantic.addKnowledge(topic, [
                        `Successfully discussed ${topic} in past conversations`,
                        `Topic ${topic} correlates with task completion`
                    ]);
                }
            });
        });
    }

    optimizeProceduralMemory(procedural) {
        // Remove or update poorly performing procedures
        procedural.procedures.forEach((procedure, name) => {
            if (procedure.success_rate < 0.3 && procedure.usage_count > 5) {
//                 console.log(`🗑️ Removing poor-performing procedure: ${name}`);
                procedural.procedures.delete(name);
            }
        });
    }
}

module.exports = {
    SemanticMemory,
    ProceduralMemory,
    KnowledgeGraph,
    ConceptNetwork,
    FactDatabase,
    DomainKnowledge,
    MemoryCoordinator
};