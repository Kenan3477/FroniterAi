import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status') || 'open';
    const page = parseInt(searchParams.get('page') || '1');
    const pageSize = parseInt(searchParams.get('pageSize') || '25');
    const search = searchParams.get('search') || '';
    const sort = searchParams.get('sort') || 'dueAt';
    const direction = searchParams.get('direction') || 'asc';

    const offset = (page - 1) * pageSize;

    // Build where clause
    const whereClause: any = {
      status: status,
    };

    if (search) {
      whereClause.OR = [
        {
          contact: {
            fullName: {
              contains: search,
              mode: 'insensitive' as const,
            },
          },
        },
        {
          notes: {
            contains: search,
            mode: 'insensitive' as const,
          },
        },
      ];
    }

    // Get total count
    const totalCount = await prisma.task.count({
      where: whereClause,
    });

    // Get tasks with related data
    const tasks = await prisma.task.findMany({
      where: whereClause,
      include: {
        assignedUser: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        contact: {
          select: {
            fullName: true,
            firstName: true,
            lastName: true,
          },
        },
        campaign: {
          select: {
            name: true,
          },
        },
      },
      orderBy: {
        [sort]: direction as 'asc' | 'desc',
      },
      skip: offset,
      take: pageSize,
    });

    // Format the response
    const formattedTasks = tasks.map(task => ({
      id: task.id,
      user: `${task.assignedUser.firstName} ${task.assignedUser.lastName}`,
      name: task.contact.fullName || `${task.contact.firstName} ${task.contact.lastName}`,
      campaign: task.campaign.name,
      type: task.type,
      notes: task.notes,
      dueAt: task.dueAt,
      status: task.status,
      createdAt: task.createdAt,
    }));

    return NextResponse.json({
      items: formattedTasks,
      totalCount,
      page,
      pageSize,
      totalPages: Math.ceil(totalCount / pageSize),
    });
  } catch (error) {
    console.error('Error fetching tasks:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}