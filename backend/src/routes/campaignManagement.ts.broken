import express from 'express';
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { campaignEvents, agentEvents, queueEvents } from '../utils/eventHelpers';

const router = express.Router();
const prisma = new PrismaClient();

// Campaign interface
interface Campaign {
  id: string;
  name: string;
  displayName: string;
  description?: string;
  status: 'DRAFT' | 'ACTIVE' | 'PAUSED' | 'COMPLETED' | 'ARCHIVED';
  category: 'SALES' | 'MARKETING' | 'SUPPORT' | 'SURVEYS' | 'COLLECTIONS' | 'NURTURE';
  type: 'OUTBOUND' | 'INBOUND' | 'BLENDED' | 'EMAIL' | 'SMS' | 'MULTICHANNEL';
  dialingMode: 'PREDICTIVE' | 'PROGRESSIVE' | 'PREVIEW' | 'MANUAL';
  maxCallsPerAgent: number;
  maxAttemptsPerRecord: number;
  abandonRateThreshold: number;
  pacingMultiplier: number;
  defaultTimezone: string;
  dialingStart?: string;
  dialingEnd?: string;
  startDate: string;
  endDate?: string;
  targetLeads: number;
  targetCompletions: number;
  expectedDuration: number;
  // Frontend display properties
  totalTargets: number;
  totalCalls: number;
  totalConnections: number;
  totalConversions: number;
  totalRevenue: number;
  budget?: number;
  budgetCurrency: string;
  priority: number;
  approvalStatus: 'PENDING' | 'APPROVED' | 'REJECTED' | 'NOT_REQUIRED';
  scheduledStart?: string;
  scheduledEnd?: string;
  openingScript?: string;
  closingScript?: string;
  emailTemplate?: string;
  smsTemplate?: string;
  isActive: boolean;
  // Dial Queue Properties
  dialMethod: 'AUTODIAL' | 'MANUAL_DIAL' | 'MANUAL_PREVIEW' | 'SKIP';
  dialSpeed: number; // Calls per minute for autodial
  agentCount: number; // Number of agents assigned to this campaign
  queuePosition?: number; // Position in dial queue
  predictiveDialingEnabled: boolean;
  maxConcurrentCalls: number;
  createdAt: string;
  updatedAt: string;
  createdBy?: {
    id: string;
    name: string;
    email: string;
  };
  assignedAgents: Array<{
    id: string;
    name: string;
    email: string;
  }>;
  dataLists: Array<{
    id: string;
    name: string;
    recordCount: number;
  }>;
  _count?: {
    interactions: number;
    contacts: number;
    completedCalls: number;
  };
}

// Campaign Template interface
interface CampaignTemplate {
  id: string;
  name: string;
  displayName: string;
  description?: string;
  category: 'SALES' | 'MARKETING' | 'SUPPORT' | 'SURVEYS' | 'COLLECTIONS' | 'NURTURE';
  type: 'OUTBOUND' | 'INBOUND' | 'BLENDED' | 'EMAIL' | 'SMS' | 'MULTICHANNEL';
  dialingMode: 'PREDICTIVE' | 'PROGRESSIVE' | 'PREVIEW' | 'MANUAL';
  maxCallsPerAgent: number;
  maxAttemptsPerRecord: number;
  abandonRateThreshold: number;
  pacingMultiplier: number;
  defaultTimezone: string;
  dialingStart?: string;
  dialingEnd?: string;
  openingScript?: string;
  closingScript?: string;
  emailTemplate?: string;
  smsTemplate?: string;
  usageCount: number;
  isActive: boolean;
  createdAt: string;
  createdBy?: {
    id: string;
    name: string;
    email: string;
  };
  _count?: {
    campaigns: number;
  };
}

// GET /api/admin/campaign-management/campaigns
router.get('/campaigns', async (req: Request, res: Response) => {
  try {
    const { status, category, type, search, page, limit } = req.query;

    // Fetch campaigns from database with related data
    const campaigns = await prisma.campaign.findMany({
      include: {
        agentAssignments: {
          include: {
            agent: true
          }
        },
        _count: {
          select: {
            interactions: true,
            callRecords: true
          }
        }
      },
      orderBy: {
        updatedAt: 'desc'
      }
    });

    // Transform to match frontend interface
    let transformedCampaigns = campaigns.map(campaign => ({
      id: campaign.id,
      campaignId: campaign.campaignId,
      name: campaign.name,
      displayName: campaign.name,
      description: campaign.description || '',
      status: campaign.status as 'DRAFT' | 'ACTIVE' | 'PAUSED' | 'COMPLETED' | 'ARCHIVED',
      category: 'SALES' as const, // Default category
      type: 'OUTBOUND' as const, // Default type
      dialingMode: 'PROGRESSIVE' as const, // Map from dialMethod
      dialMethod: campaign.dialMethod as 'AUTODIAL' | 'MANUAL_DIAL' | 'MANUAL_PREVIEW' | 'SKIP',
      dialSpeed: campaign.speed,
      maxCallsPerAgent: campaign.maxCallsPerAgent || 1,
      maxAttemptsPerRecord: 3, // Default value
      abandonRateThreshold: campaign.abandonRateThreshold || 0.05,
      pacingMultiplier: campaign.pacingMultiplier || 1.0,
      defaultTimezone: 'UTC', // Default timezone
      startDate: campaign.createdAt.toISOString(),
      targetLeads: 0, // Will be calculated from data lists
      targetCompletions: 0, // Will be calculated
      expectedDuration: 60, // Default duration in minutes
      totalTargets: 0,
      totalCalls: campaign._count.callRecords,
      totalConnections: 0,
      totalConversions: 0,
      totalRevenue: 0,
      budget: 0,
      budgetCurrency: 'USD',
      priority: 1,
      approvalStatus: 'NOT_REQUIRED' as const,
      isActive: campaign.status === 'ACTIVE',
      agentCount: campaign.agentAssignments.length,
      predictiveDialingEnabled: false,
      maxConcurrentCalls: campaign.maxCallsPerAgent || 1,
      createdAt: campaign.createdAt.toISOString(),
      updatedAt: campaign.updatedAt.toISOString(),
      assignedAgents: campaign.agentAssignments.map(assignment => ({
        id: assignment.agent.agentId,
        name: `${assignment.agent.firstName} ${assignment.agent.lastName}`,
        email: assignment.agent.email
      })),
      dataLists: [], // Will be populated when data list integration is implemented
      _count: {
        interactions: campaign._count.interactions,
        contacts: 0, // Will be calculated from data lists
        completedCalls: campaign._count.callRecords
      }
    }));

    // Apply filters
    if (status) {
      transformedCampaigns = transformedCampaigns.filter(c => c.status === status);
    }
    if (category) {
      transformedCampaigns = transformedCampaigns.filter(c => c.category === category);
    }
    if (type) {
      transformedCampaigns = transformedCampaigns.filter(c => c.type === type);
    }
    if (search) {
      const searchTerm = (search as string).toLowerCase();
      transformedCampaigns = transformedCampaigns.filter(c => 
        c.name.toLowerCase().includes(searchTerm) ||
        c.displayName.toLowerCase().includes(searchTerm) ||
        (c.description && c.description.toLowerCase().includes(searchTerm))
      );
    }

    // Pagination
    const pageNumber = parseInt(page as string) || 1;
    const limitNumber = parseInt(limit as string) || 20;
    const offset = (pageNumber - 1) * limitNumber;
    const paginatedCampaigns = transformedCampaigns.slice(offset, offset + limitNumber);

    // Support both response formats for backward compatibility
    if (page || limit) {
      res.json({
        success: true,
        data: {
          campaigns: paginatedCampaigns,
          pagination: {
            page: pageNumber,
            limit: limitNumber,
            total: transformedCampaigns.length,
            totalPages: Math.ceil(transformedCampaigns.length / limitNumber)
          }
        }
      });
    } else {
      res.json({
        success: true,
        data: transformedCampaigns,
        count: transformedCampaigns.length
      });
    }
  } catch (error) {
    console.error('Error fetching campaigns:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch campaigns'
    });
  }
});

// GET /api/admin/campaign-management/templates
router.get('/templates', async (req: Request, res: Response) => {
  try {
    // For now, return empty templates array
    // Campaign templates will be implemented as a separate feature
    res.json({
      success: true,
      data: [],
      count: 0
    });
  } catch (error) {
    console.error('Error fetching campaign templates:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch campaign templates'
    });
  }
});

// Mock data for templates
let mockTemplates: CampaignTemplate[] = [
  {
    id: 'template_001',
    name: 'SALES_OUTBOUND_PROGRESSIVE',
    displayName: 'Sales Outbound - Progressive',
    description: 'Standard template for outbound sales campaigns with progressive dialing',
    category: 'SALES',
    type: 'OUTBOUND',
    dialingMode: 'PROGRESSIVE',
    maxCallsPerAgent: 50,
    maxAttemptsPerRecord: 3,
    abandonRateThreshold: 5,
    pacingMultiplier: 1.2,
    defaultTimezone: 'Europe/London',
    dialingStart: '09:00',
    dialingEnd: '17:00',
    openingScript: 'Hi, this is [Agent Name] calling from [Company]. Is this a good time to talk?',
    closingScript: 'Thank you for your time today. Have a great day!',
    usageCount: 15,
    isActive: true,
    createdAt: '2024-01-15T00:00:00Z',
    createdBy: {
      id: 'user_001',
      name: 'Sarah Johnson',
      email: 'sarah.johnson@company.com'
    },
    _count: {
      campaigns: 15
    }
  },
  {
    id: 'template_002',
    name: 'CUSTOMER_SURVEY_PREVIEW',
    displayName: 'Customer Survey - Preview',
    description: 'Template for customer satisfaction surveys with preview dialing',
    category: 'SURVEYS',
    type: 'OUTBOUND',
    dialingMode: 'PREVIEW',
    maxCallsPerAgent: 30,
    maxAttemptsPerRecord: 2,
    abandonRateThreshold: 3,
    pacingMultiplier: 1.0,
    defaultTimezone: 'Europe/London',
    dialingStart: '10:00',
    dialingEnd: '16:00',
    openingScript: 'Hello, we\'re conducting a brief satisfaction survey. Do you have 5 minutes?',
    closingScript: 'Thank you for participating in our survey. Your feedback is valuable to us.',
    usageCount: 8,
    isActive: true,
    createdAt: '2024-02-20T00:00:00Z',
    createdBy: {
      id: 'user_002',
      name: 'Mike Wilson',
      email: 'mike.wilson@company.com'
    },
    _count: {
      campaigns: 8
    }
  }
];

// GET /api/admin/campaign-management/stats
router.get('/stats', async (req: Request, res: Response) => {
  try {
    // Fetch campaigns from database for stats calculation
    const campaigns = await prisma.campaign.findMany({
      include: {
        _count: {
          select: {
            interactions: true,
            callRecords: true
          }
        }
      }
    });

    const activeCampaigns = campaigns.filter(c => c.status === 'ACTIVE');
    const totalInteractions = campaigns.reduce((sum, c) => sum + (c._count?.interactions || 0), 0);
    const totalContacts = 0; // Will be calculated from data lists when integrated
    const totalCompletedCalls = campaigns.reduce((sum, c) => sum + (c._count?.callRecords || 0), 0);

    const stats = {
      totalCampaigns: campaigns.length,
      activeCampaigns: activeCampaigns.length,
      draftCampaigns: campaigns.filter(c => c.status === 'DRAFT').length,
      pausedCampaigns: campaigns.filter(c => c.status === 'PAUSED').length,
      completedCampaigns: campaigns.filter(c => c.status === 'COMPLETED').length,
      totalTemplates: 0, // Templates not implemented yet
      totalInteractions,
      totalContacts,
      totalCompletedCalls,
      conversionRate: totalContacts > 0 ? (totalCompletedCalls / totalContacts * 100).toFixed(2) : '0.00',
      averageCallsPerCampaign: campaigns.length > 0 ? (totalCompletedCalls / campaigns.length).toFixed(1) : '0.0'
    };

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('Error fetching campaign stats:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error fetching campaign stats' }
    });
  }
});

// POST /api/admin/campaign-management/campaigns
router.post('/campaigns', async (req: Request, res: Response) => {
  try {
    const campaignData = req.body;

    // Create campaign in database
    const newCampaign = await prisma.campaign.create({
      data: {
        campaignId: `campaign_${Date.now()}`,
        name: campaignData.name,
        description: campaignData.description,
        dialMethod: campaignData.dialMethod || 'Progressive',
        speed: campaignData.dialSpeed || 2.0,
        status: 'Inactive', // Start inactive, user can activate later
        maxCallsPerAgent: campaignData.maxCallsPerAgent || 1,
        abandonRateThreshold: campaignData.abandonRateThreshold || 0.05,
        pacingMultiplier: campaignData.pacingMultiplier || 1.0,
        recordCalls: campaignData.recordCalls || false,
        allowTransfers: campaignData.allowTransfers || false,
        campaignScript: campaignData.openingScript || '',
        fieldMapping: JSON.stringify({}), // Empty field mapping initially
        retrySettings: JSON.stringify({
          maxAttempts: campaignData.maxAttemptsPerRecord || 3,
          retryDelay: 3600 // 1 hour default retry delay
        }),
        hoursOfOperation: JSON.stringify({
          timezone: campaignData.defaultTimezone || 'UTC',
          schedule: {
            monday: { enabled: true, start: '09:00', end: '17:00' },
            tuesday: { enabled: true, start: '09:00', end: '17:00' },
            wednesday: { enabled: true, start: '09:00', end: '17:00' },
            thursday: { enabled: true, start: '09:00', end: '17:00' },
            friday: { enabled: true, start: '09:00', end: '17:00' },
            saturday: { enabled: false, start: '09:00', end: '17:00' },
            sunday: { enabled: false, start: '09:00', end: '17:00' }
          }
        })
      },
      include: {
        agentAssignments: {
          include: {
            agent: true
          }
        },
        _count: {
          select: {
            interactions: true,
            callRecords: true
          }
        }
      }
    });

    // Transform response to match frontend interface
    const transformedCampaign = {
      id: newCampaign.id,
      campaignId: newCampaign.campaignId,
      name: newCampaign.name,
      displayName: newCampaign.name,
      description: newCampaign.description || '',
      status: newCampaign.status as 'DRAFT' | 'ACTIVE' | 'PAUSED' | 'COMPLETED' | 'ARCHIVED',
      category: 'SALES' as const,
      type: 'OUTBOUND' as const,
      dialingMode: 'PROGRESSIVE' as const,
      dialMethod: newCampaign.dialMethod as 'AUTODIAL' | 'MANUAL_DIAL' | 'MANUAL_PREVIEW' | 'SKIP',
      dialSpeed: newCampaign.speed,
      maxCallsPerAgent: newCampaign.maxCallsPerAgent || 1,
      maxAttemptsPerRecord: 3,
      abandonRateThreshold: newCampaign.abandonRateThreshold || 0.05,
      pacingMultiplier: newCampaign.pacingMultiplier || 1.0,
      defaultTimezone: 'UTC',
      startDate: newCampaign.createdAt.toISOString(),
      targetLeads: 0,
      targetCompletions: 0,
      expectedDuration: 60,
      totalTargets: 0,
      totalCalls: newCampaign._count.callRecords,
      totalConnections: 0,
      totalConversions: 0,
      totalRevenue: 0,
      budget: 0,
      budgetCurrency: 'USD',
      priority: 1,
      approvalStatus: 'NOT_REQUIRED' as const,
      isActive: newCampaign.status === 'ACTIVE',
      agentCount: newCampaign.agentAssignments.length,
      predictiveDialingEnabled: false,
      maxConcurrentCalls: newCampaign.maxCallsPerAgent || 1,
      createdAt: newCampaign.createdAt.toISOString(),
      updatedAt: newCampaign.updatedAt.toISOString(),
      assignedAgents: newCampaign.agentAssignments.map(assignment => ({
        id: assignment.agent.agentId,
        name: `${assignment.agent.firstName} ${assignment.agent.lastName}`,
        email: assignment.agent.email
      })),
      dataLists: [],
      _count: {
        interactions: newCampaign._count.interactions,
        contacts: 0,
        completedCalls: newCampaign._count.callRecords
      }
    };

    res.status(201).json({
      success: true,
      data: {
        campaign: transformedCampaign,
        message: 'Campaign created successfully'
      }
    });

  } catch (error) {
    console.error('Error creating campaign:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error creating campaign' }
    });
  }
});

// PUT /api/admin/campaign-management/campaigns/:id
router.put('/campaigns/:id', (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    const campaignIndex = campaigns.findIndex(c => c.id === id);
    if (campaignIndex === -1) {
      return res.status(404).json({
        success: false,
        error: { message: 'Campaign not found' }
      });
    }

    // Update campaign
    campaigns[campaignIndex] = {
      ...campaigns[campaignIndex],
      ...updateData,
      updatedAt: new Date().toISOString()
    };

    res.json({
      success: true,
      data: {
        campaign: campaigns[campaignIndex],
        message: 'Campaign updated successfully'
      }
    });

  } catch (error) {
    console.error('Error updating campaign:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error updating campaign' }
    });
  }
});

// DELETE /api/admin/campaign-management/campaigns/:id
router.delete('/campaigns/:id', (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const campaignIndex = campaigns.findIndex(c => c.id === id);
    if (campaignIndex === -1) {
      return res.status(404).json({
        success: false,
        error: { message: 'Campaign not found' }
      });
    }

    const deletedCampaign = campaigns.splice(campaignIndex, 1)[0];

    res.json({
      success: true,
      data: {
        campaign: deletedCampaign,
        message: 'Campaign deleted successfully'
      }
    });

  } catch (error) {
    console.error('Error deleting campaign:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error deleting campaign' }
    });
  }
});

// DIAL QUEUE API ENDPOINTS

// PATCH /api/admin/campaign-management/campaigns/:id/dial-method
router.patch('/campaigns/:id/dial-method', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { dialMethod } = req.body;

    const campaign = campaigns.find(c => c.id === id);
    if (!campaign) {
      return res.status(404).json({
        success: false,
        error: { message: 'Campaign not found' }
      });
    }

    const previousDialMethod = campaign.dialMethod;
    campaign.dialMethod = dialMethod;
    campaign.updatedAt = new Date().toISOString();

    // Emit campaign dial method change event
    await campaignEvents.dialMethodChanged({
      campaignId: campaign.id,
      campaignName: campaign.displayName,
      dialMethod,
      previousState: { dialMethod: previousDialMethod },
    });

    res.json({
      success: true,
      data: { campaign, message: 'Dial method updated successfully' }
    });

  } catch (error) {
    console.error('Error updating dial method:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error updating dial method' }
    });
  }
});

// PATCH /api/admin/campaign-management/campaigns/:id/activate
router.patch('/campaigns/:id/activate', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { isActive } = req.body;

    const campaign = campaigns.find(c => c.id === id);
    if (!campaign) {
      return res.status(404).json({
        success: false,
        error: { message: 'Campaign not found' }
      });
    }

    const previousStatus = campaign.status;
    const previousActive = campaign.isActive;
    
    campaign.isActive = isActive;
    campaign.updatedAt = new Date().toISOString();

    // Update campaign status based on activation
    if (isActive && campaign.status === 'PAUSED') {
      campaign.status = 'ACTIVE';
    } else if (!isActive && campaign.status === 'ACTIVE') {
      campaign.status = 'PAUSED';
    }

    // Emit appropriate campaign event
    if (isActive && previousStatus === 'PAUSED') {
      await campaignEvents.started({
        campaignId: campaign.id,
        campaignName: campaign.displayName,
        status: campaign.status,
        agentCount: campaign.agentCount,
        dialMethod: campaign.dialMethod,
      });
    } else if (!isActive && previousStatus === 'ACTIVE') {
      await campaignEvents.paused({
        campaignId: campaign.id,
        campaignName: campaign.displayName,
        status: campaign.status,
        agentCount: campaign.agentCount,
      });
    } else {
      await campaignEvents.updated({
        campaignId: campaign.id,
        campaignName: campaign.displayName,
        status: campaign.status,
        previousState: { 
          isActive: previousActive, 
          status: previousStatus 
        },
      });
    }

    res.json({
      success: true,
      data: { campaign, message: `Campaign ${isActive ? 'activated' : 'deactivated'} successfully` }
    });

  } catch (error) {
    console.error('Error toggling campaign activation:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error toggling campaign activation' }
    });
  }
});

// PATCH /api/admin/campaign-management/campaigns/:id/dial-speed
router.patch('/campaigns/:id/dial-speed', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { dialSpeed } = req.body;

    const campaign = campaigns.find(c => c.id === id);
    if (!campaign) {
      return res.status(404).json({
        success: false,
        error: { message: 'Campaign not found' }
      });
    }

    // Validate dial speed (1-300 calls per minute)
    if (dialSpeed < 1 || dialSpeed > 300) {
      return res.status(400).json({
        success: false,
        error: { message: 'Dial speed must be between 1 and 300 calls per minute' }
      });
    }

    const previousDialSpeed = campaign.dialSpeed;
    campaign.dialSpeed = dialSpeed;
    campaign.updatedAt = new Date().toISOString();

    // Emit campaign dial speed change event
    await campaignEvents.dialSpeedChanged({
      campaignId: campaign.id,
      campaignName: campaign.displayName,
      dialSpeed,
      previousState: { dialSpeed: previousDialSpeed },
    });

    res.json({
      success: true,
      data: { campaign, message: 'Dial speed updated successfully' }
    });

  } catch (error) {
    console.error('Error updating dial speed:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error updating dial speed' }
    });
  }
});

// POST /api/admin/campaign-management/campaigns/:id/join-agent
router.post('/campaigns/:id/join-agent', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { agentId, agentName, agentEmail } = req.body;

    const campaign = campaigns.find(c => c.id === id);
    if (!campaign) {
      return res.status(404).json({
        success: false,
        error: { message: 'Campaign not found' }
      });
    }

    // Check if agent is already assigned
    const existingAgent = campaign.assignedAgents.find(agent => 
      agent.id === agentId || agent.email === agentEmail
    );

    if (existingAgent) {
      return res.status(400).json({
        success: false,
        error: { message: 'Agent is already assigned to this campaign' }
      });
    }

    // Add agent to campaign
    const newAgent = {
      id: agentId || `agent_${Date.now()}`,
      name: agentName || 'Unknown Agent',
      email: agentEmail || ''
    };

    campaign.assignedAgents.push(newAgent);
    campaign.agentCount = campaign.assignedAgents.length;
    campaign.updatedAt = new Date().toISOString();

    // Emit agent joined campaign event
    await agentEvents.joinedCampaign({
      agentId: newAgent.id,
      agentName: newAgent.name,
      campaignId: campaign.id,
      campaignName: campaign.displayName,
    });

    res.json({
      success: true,
      data: { 
        campaign, 
        agent: newAgent,
        message: 'Agent joined campaign successfully' 
      }
    });

  } catch (error) {
    console.error('Error adding agent to campaign:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error adding agent to campaign' }
    });
  }
});

// POST /api/admin/campaign-management/campaigns/:id/leave-agent
router.post('/campaigns/:id/leave-agent', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { agentId } = req.body;

    const campaign = campaigns.find(c => c.id === id);
    if (!campaign) {
      return res.status(404).json({
        success: false,
        error: { message: 'Campaign not found' }
      });
    }

    // If no specific agent ID provided, remove the most recently added agent
    let agentIndex = -1;
    if (agentId) {
      agentIndex = campaign.assignedAgents.findIndex(agent => agent.id === agentId);
    } else {
      agentIndex = campaign.assignedAgents.length - 1;
    }

    if (agentIndex === -1 || campaign.assignedAgents.length === 0) {
      return res.status(400).json({
        success: false,
        error: { message: 'No agents to remove from this campaign' }
      });
    }

    // Remove agent from campaign
    const removedAgent = campaign.assignedAgents.splice(agentIndex, 1)[0];
    campaign.agentCount = campaign.assignedAgents.length;
    campaign.updatedAt = new Date().toISOString();

    // Emit agent left campaign event
    await agentEvents.leftCampaign({
      agentId: removedAgent.id,
      agentName: removedAgent.name,
      campaignId: campaign.id,
      campaignName: campaign.displayName,
    });

    res.json({
      success: true,
      data: { 
        campaign, 
        removedAgent,
        message: 'Agent removed from campaign successfully' 
      }
    });

  } catch (error) {
    console.error('Error removing agent from campaign:', error);
    res.status(500).json({
      success: false,
      error: { message: 'Internal server error removing agent from campaign' }
    });
  }
});

export default router;