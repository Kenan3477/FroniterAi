import { Request, Response } from 'express';
import { z } from 'zod';
import CryptoJS from 'crypto-js';
import crypto from 'crypto';
import { prisma } from '../database';

// Generate a secure random API key
const generateApiKey = () => {
  const randomBytes = crypto.randomBytes(32);
  return randomBytes.toString('hex');
};

// Generate API key prefix based on environment
const generateKeyPrefix = (environment: string) => {
  const prefixes = {
    production: 'sk_live_',
    staging: 'sk_test_',
    development: 'sk_dev_'
  };
  return prefixes[environment as keyof typeof prefixes] || 'sk_live_';
};

// Hash API key for storage
const hashApiKey = (key: string) => {
  return CryptoJS.SHA256(key).toString();
};

// Validation schemas
const createApiKeySchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  description: z.string().optional(),
  scopes: z.array(z.string()).default(['read']),
  environment: z.enum(['production', 'staging', 'development']).default('production'),
  rateLimit: z.number().positive().optional(),
  expiresAt: z.string().datetime().optional().or(z.null())
});

const updateApiKeySchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().optional().or(z.null()),
  scopes: z.array(z.string()).optional(),
  rateLimit: z.number().positive().optional().or(z.null()),
  isActive: z.boolean().optional(),
  expiresAt: z.string().datetime().optional().or(z.null())
});

// Get all API keys for the authenticated user
export const getApiKeys = async (req: Request, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = Math.min(parseInt(req.query.limit as string) || 10, 100);
    const skip = (page - 1) * limit;
    
    const environment = req.query.environment as string;
    const isActive = req.query.isActive === 'true' ? true : 
                    req.query.isActive === 'false' ? false : undefined;

    const where = {
      createdByUserId: 'temp-admin-user', // TODO: Get from authenticated user
      ...(environment && { environment }),
      ...(isActive !== undefined && { isActive })
    };

    const [apiKeys, total] = await Promise.all([
      prisma.apiKey.findMany({
        where,
        select: {
          id: true,
          name: true,
          description: true,
          prefix: true,
          scopes: true,
          environment: true,
          rateLimit: true,
          usageCount: true,
          lastUsedAt: true,
          isActive: true,
          expiresAt: true,
          createdAt: true,
          updatedAt: true
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.apiKey.count({ where })
    ]);

    // Parse JSON scopes
    const formattedApiKeys = apiKeys.map((key: any) => ({
      ...key,
      scopes: JSON.parse(key.scopes || '["read"]'),
      // Show only prefix + last 4 characters for security
      maskedKey: key.prefix + '****'
    }));

    res.json({
      data: formattedApiKeys,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1
      }
    });
  } catch (error) {
    console.error('Error fetching API keys:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// Create a new API key
export const createApiKey = async (req: Request, res: Response) => {
  try {
    const validatedData = createApiKeySchema.parse(req.body);
    
    // Generate the actual API key
    const apiKey = generateApiKey();
    const prefix = generateKeyPrefix(validatedData.environment);
    const fullKey = prefix + apiKey;
    const keyHash = hashApiKey(fullKey);

    const newApiKey = await prisma.apiKey.create({
      data: {
        name: validatedData.name,
        description: validatedData.description,
        keyHash,
        prefix,
        scopes: JSON.stringify(validatedData.scopes),
        environment: validatedData.environment,
        rateLimit: validatedData.rateLimit,
        expiresAt: validatedData.expiresAt ? new Date(validatedData.expiresAt) : null,
        createdByUserId: 'temp-admin-user' // TODO: Get from authenticated user
      },
      select: {
        id: true,
        name: true,
        description: true,
        prefix: true,
        scopes: true,
        environment: true,
        rateLimit: true,
        isActive: true,
        expiresAt: true,
        createdAt: true
      }
    });

    // Return the full key only once (for copying)
    res.status(201).json({
      ...newApiKey,
      scopes: JSON.parse(newApiKey.scopes || '["read"]'),
      apiKey: fullKey, // Only returned on creation
      warning: 'Save this key securely. It will not be shown again.'
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        error: 'Validation error',
        details: error.errors
      });
    }
    console.error('Error creating API key:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// Update an API key
export const updateApiKey = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const validatedData = updateApiKeySchema.parse(req.body);

    const existingKey = await prisma.apiKey.findFirst({
      where: {
        id,
        createdByUserId: 'temp-admin-user' // TODO: Get from authenticated user
      }
    });

    if (!existingKey) {
      return res.status(404).json({ error: 'API key not found' });
    }

    const updateData: any = {};
    
    if (validatedData.name !== undefined) updateData.name = validatedData.name;
    if (validatedData.description !== undefined) updateData.description = validatedData.description;
    if (validatedData.scopes !== undefined) updateData.scopes = JSON.stringify(validatedData.scopes);
    if (validatedData.rateLimit !== undefined) updateData.rateLimit = validatedData.rateLimit;
    if (validatedData.isActive !== undefined) updateData.isActive = validatedData.isActive;
    if (validatedData.expiresAt !== undefined) {
      updateData.expiresAt = validatedData.expiresAt ? new Date(validatedData.expiresAt) : null;
    }

    const updatedKey = await prisma.apiKey.update({
      where: { id },
      data: updateData,
      select: {
        id: true,
        name: true,
        description: true,
        prefix: true,
        scopes: true,
        environment: true,
        rateLimit: true,
        usageCount: true,
        lastUsedAt: true,
        isActive: true,
        expiresAt: true,
        createdAt: true,
        updatedAt: true
      }
    });

    res.json({
      ...updatedKey,
      scopes: JSON.parse(updatedKey.scopes || '["read"]'),
      maskedKey: updatedKey.prefix + '****'
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        error: 'Validation error',
        details: error.errors
      });
    }
    console.error('Error updating API key:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// Delete an API key
export const deleteApiKey = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const existingKey = await prisma.apiKey.findFirst({
      where: {
        id,
        createdByUserId: 'temp-admin-user' // TODO: Get from authenticated user
      }
    });

    if (!existingKey) {
      return res.status(404).json({ error: 'API key not found' });
    }

    await prisma.apiKey.delete({
      where: { id }
    });

    res.status(204).send();
  } catch (error) {
    console.error('Error deleting API key:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// Get API key statistics
export const getApiKeyStats = async (req: Request, res: Response) => {
  try {
    const userId = 'temp-admin-user'; // TODO: Get from authenticated user

    const [total, active, expired, byEnvironment, recentUsage] = await Promise.all([
      // Total API keys
      prisma.apiKey.count({
        where: { createdByUserId: userId }
      }),
      
      // Active API keys
      prisma.apiKey.count({
        where: { 
          createdByUserId: userId,
          isActive: true,
          OR: [
            { expiresAt: null },
            { expiresAt: { gte: new Date() } }
          ]
        }
      }),

      // Expired API keys
      prisma.apiKey.count({
        where: { 
          createdByUserId: userId,
          expiresAt: { lt: new Date() }
        }
      }),

      // By environment
      prisma.apiKey.groupBy({
        by: ['environment'],
        where: { createdByUserId: userId },
        _count: true
      }),

      // Recent usage (last 30 days)
      prisma.apiUsageLog.count({
        where: {
          apiKey: {
            createdByUserId: userId
          },
          timestamp: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 30 days ago
          }
        }
      })
    ]);

    const environmentStats = byEnvironment.reduce((acc: Record<string, number>, env: any) => {
      acc[env.environment] = env._count;
      return acc;
    }, {} as Record<string, number>);

    res.json({
      total,
      active,
      expired,
      inactive: total - active,
      byEnvironment: {
        production: environmentStats.production || 0,
        staging: environmentStats.staging || 0,
        development: environmentStats.development || 0
      },
      recentUsage
    });
  } catch (error) {
    console.error('Error fetching API key stats:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// Get usage logs for an API key
export const getApiKeyUsage = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const page = parseInt(req.query.page as string) || 1;
    const limit = Math.min(parseInt(req.query.limit as string) || 50, 200);
    const skip = (page - 1) * limit;

    // Verify API key ownership
    const apiKey = await prisma.apiKey.findFirst({
      where: {
        id,
        createdByUserId: 'temp-admin-user' // TODO: Get from authenticated user
      }
    });

    if (!apiKey) {
      return res.status(404).json({ error: 'API key not found' });
    }

    const [usageLogs, total] = await Promise.all([
      prisma.apiUsageLog.findMany({
        where: { apiKeyId: id },
        orderBy: { timestamp: 'desc' },
        skip,
        take: limit
      }),
      prisma.apiUsageLog.count({
        where: { apiKeyId: id }
      })
    ]);

    res.json({
      data: usageLogs,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1
      }
    });
  } catch (error) {
    console.error('Error fetching API key usage:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// Bulk operations
export const bulkUpdateApiKeys = async (req: Request, res: Response) => {
  try {
    const { ids, action, ...updateData } = req.body;

    if (!Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ error: 'Invalid or empty IDs array' });
    }

    let updates: any = {};

    switch (action) {
      case 'activate':
        updates = { isActive: true };
        break;
      case 'deactivate':
        updates = { isActive: false };
        break;
      case 'update':
        const validatedData = updateApiKeySchema.partial().parse(updateData);
        if (validatedData.scopes) {
          validatedData.scopes = JSON.stringify(validatedData.scopes) as any;
        }
        updates = validatedData;
        break;
      default:
        return res.status(400).json({ error: 'Invalid action' });
    }

    const result = await prisma.apiKey.updateMany({
      where: {
        id: { in: ids },
        createdByUserId: 'temp-admin-user' // TODO: Get from authenticated user
      },
      data: updates
    });

    res.json({ 
      message: `Updated ${result.count} API keys`,
      updated: result.count
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        error: 'Validation error',
        details: error.errors
      });
    }
    console.error('Error in bulk update:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};